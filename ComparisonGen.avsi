### A script for saving images from up to 5 clips.


### Usage ###
###
# Function ComparisonGen(val c, string frames_file, val "image_file", val "frame_type", bool "pframes_file", int "n", float "offset_coef", string "matrix", string "pixel_type")
###
## Parameters ##
#---------------
# c: Input clips.
# Type of array.
# Clips must be between 2..5.
#---------------
# frames_file: The path+filename of the file containing the frames that will be saved as images.
#---------------
# image_file (default ["%06dsource.png", "%06dencode.png", "%06dencode1.png", "%06dencode2.png", "%06dencode3.png"]): The path+filename of the new saved images.
# Type of array.
# It must have the same length as 'c'.
#---------------
# frame_type (default [4, 3, 3, 3, 3]): Frame types that will be saved.
# Type of array.
# It must have the same length as 'c'.
# The values must be between 1..4.
# 1: Corresponds to "I" frame.
# 2: Corresponds to "P" frame.
# 3: Corresponds to "B" frame.
# 4: Corresponds to either "P" or "B" frame. 
#---------------
# pframes_file (default false): Whether an already created file with frames is supplied.
# False: A source filter (FFMS2/LSMASHSource/D2VSource) with support of "_PictType" frame property is required. The file with the frames contains random frames generated by SelectRangeEvery.
# True: It's assumed that the frames in the alrady created file are already selected so all frames in the file will be saved as images.
#---------------
# n (default 10): How many frames will be selected.
# It has effect when pframes_file=false.
# Note that the final frames number could be smaller if the selected frames don't match the frame types. 
#---------------
# offset_coef (default 0.05 (5% of total frames)): The offset of SelectRangeEvery.
# It has effect when pframes_file=false.
#---------------
# matrix (default "709=>rgb"): Used matrix for converting to RGB before saving the png files.
# It has effect when the clips are in YUV format.
#---------------
# pixel_type (default "RGBP"): Pixel_type when converting to RGB before saving the png files.
# Use "RGBP16" for 16-bit png files.


### Example of frames_file ###
/*
2
48
5567
95642
*/


### Examples ###
/*
s=FFVideoSource(source).Crop(0, 148, -0, -148).LWLinfo()
e=FFVideoSource(encode).LWLinfo()
ComparisonGen([s, e], "rr.txt") # File rr.txt with frames ("P/B" source frame type and "B" encode frame type) will be created and then source+encode images will be saved. All files will be saved in the same folder where the script is located.
*/
###
/*
s=FFVideoSource(source).Crop(0, 148, -0, -148).LWLinfo()
e=FFVideoSource(encode).LWLinfo()
ComparisonGen([s, e], "D:\rr.txt", pframes_file=true) # Already created file with name "rr.txt" in D:\ containing the frames will be used.
*/
###
/*
s=FFVideoSource(source).Crop(0, 148, -0, -148).LWLinfo()
e=FFVideoSource(encode).LWLinfo()
ComparisonGen([s, e], "rr.txt", image_file=["d:\source%03d.png", "d:\encode%03d.png"]) # Source images will be saved in D:\ with names "sourcexxx.png" and encode images will be saved in D:\ with names "encodexxx.png".
*/
###
/*
s=FFVideoSource(source).Crop(0, 148, -0, -148).LWLinfo()
e=FFVideoSource(encode).LWLinfo()
e1=FFVideoSource(encode1).LWLinfo()
e2=FFVideoSource(encode2).LWLinfo()
e3=FFVideoSource(encode3).LWLinfo()
ComparisonGen([s, e, e1, e2, e3, e4], "rr.txt", frame_type=[4, 3, 3, 4, 4]) # The frames will be saved as images only if source frame type is 'P/B', encode frame type is 'B', encode1 frame type is 'B', encode2 frame type is 'P/B', encode3 frame type is 'P/B'.
*/


### How to run the created script ###
/*
Two options:
1.) If you don't want to create a script then write the commands (like examples above) in AvsPmod/VirtualDub, hit Refresh and wait until you see the message 'Done.'.
2.) If you create .avs script then you could open it with:
- avsr ( https://forum.doom9.org/showthread.php?t=173259 ): avsr(64) script_name.avs;
- avsmeter ( https://forum.doom9.org/showthread.php?t=174797 ): avsmeter(64) script_name.avs;
- ffmpeg: ffmpeg -i script_name.avs -f null - ;
- AvsPmod: 1) import("script_name.avs") and 2) Video->Run analysis pass.

Note - if AvsPmod is used and default s_image_file and e_image_file are used, the images will be saved in the AvsPmod folder instead in the folder where the *.avs script is located.
*/


### Changelog ###
# Added suport for up to 5 clips.
# Added new parameter 'frame_type'.
# Changed clip type to array.
# Merged parameters 's_image_file' and 'e_image_file' to one parameter 'image_file' (type array).
# Allowed RGB clips.
#---------------
# Removed support for FFMS2 variables.
#---------------
# Added support for LSMASHSource picture type.
#---------------
# WriteFile replaced with RT_WriteFile.
#---------------
# Script info changed, fixed ScriptClip error message.
#---------------
# Initial version.


Function ComparisonGen(val c, string frames_file, val "image_file", val "frame_type", bool "pframes_file", int "n", float "offset_coef", string "matrix", string "pixel_type")
{
    Assert(ArraySize(c) >= 2, "ComparisonGen: at least two clips are required.")
    Assert(ArraySize(c) <= 5, "ComparisonGen: maximum 5 clips are supported.")
    
    for (i = 1, ArraySize(c) - 1)
    {
        Assert(FrameCount(c[0]) == FrameCount(c[i]), "ComparisonGen: clips must have same total number of frames.")
        Assert(PixelType(c[0]) == PixelType(c[i]), "ComparisonGen: clips must have same pixel type.")
    }  
    
    _image = 
    \ (!Defined(image_file)) ?
        \ (ArraySize(c) == 2) ? 
            \ ["%06dsource.png", "%06dencode.png"] :
        \ (ArraySize(c) == 3) ?
            \ ["%06dsource.png", "%06dencode.png", "%06dencode1.png"] :
        \  (ArraySize(c) == 4) ?
            \ ["%06dsource.png", "%06dencode.png", "%06dencode1.png", "%06dencode2.png"] :
        \ ["%06dsource.png", "%06dencode.png", "%06dencode1.png", "%06dencode2.png", "%06dencode3.png"] :
    \ image_file
    
    Assert(ArraySize(c) == ArraySize(_image), "ComparisonGen: more or less 'image_file' given than there are clips.")
        
    _types =
    \ (!Defined(frame_type)) ?
        \ (ArraySize(c) == 2) ? 
            \ [4, 3] :
        \ (ArraySize(c) == 3) ?
            \ [4, 3, 3] :
        \ (ArraySize(c) == 4) ?
            \ [4, 3, 3, 3] :
        \ [4, 3, 3, 3, 3] :
    \ frame_type
    
    Assert(ArraySize(c) == ArraySize(_types), "ComparisonGen: more or less 'frame_type' given than there are clips.")
    for (i = 0, ArraySize(_types) - 1)
    {
        Assert(_types[i] > 0 && _types[i] <= 4, "ComparisonGen: 'frame_type' values must be between 1..4.")
    }

    pframes_file = Default(pframes_file, false)  
    matrix = Default(matrix, "709=>rgb")
    pixel_type = Default(pixel_type, "RGBP")
    
    if (!pframes_file)
    {
        n = Default(n, 10)
        offset_coef = Default(offset_coef, 0.05)
        offset = Int(FrameCount(c[0]) * offset_coef)
        
        _clip =
        \ (ArraySize(c) == 2) ?
            \ [SelectRangeEvery(c[0], (FrameCount(c[0]) / n), 1, offset), SelectRangeEvery(c[1], (FrameCount(c[0]) / n), 1, offset)] :
        \ (ArraySize(c) == 3) ?
            \ [SelectRangeEvery(c[0], (FrameCount(c[0]) / n), 1, offset), SelectRangeEvery(c[1], (FrameCount(c[0]) / n), 1, offset), SelectRangeEvery(c[2], (FrameCount(c[0]) / n), 1, offset)] :
        \ (ArraySize(c) == 4) ?
            \ [SelectRangeEvery(c[0], (FrameCount(c[0]) / n), 1, offset), SelectRangeEvery(c[1], (FrameCount(c[0]) / n), 1, offset), SelectRangeEvery(c[2], (FrameCount(c[0]) / n), 1, offset), SelectRangeEvery(c[3], (FrameCount(c[0]) / n), 1, offset)] :
        \ [SelectRangeEvery(c[0], (FrameCount(c[0]) / n), 1, offset), SelectRangeEvery(c[1], (FrameCount(c[0]) / n), 1, offset), SelectRangeEvery(c[2], (FrameCount(c[0]) / n), 1, offset), SelectRangeEvery(c[3], (FrameCount(c[0]) / n), 1, offset), SelectRangeEvery(c[4], (FrameCount(c[0]) / n), 1, offset)]
        
        fw(_clip, frames_file, _types)
    }
    else
    {
        _clip = c
    }
    
    if (IsRGB(c[0]))
    {
        for (i = 0, ArraySize(c) - 1)
        {
            simage(z_ConvertFormat(FrameSel(_clip[i], cmd=frames_file), pixel_type=pixel_type, dither_type="error_diffusion"), _image[i])
        }
    }
    else
    {
        for (i = 0, ArraySize(c) - 1)
        {
            simage(z_ConvertFormat(FrameSel(_clip[i], cmd=frames_file), pixel_type=pixel_type, colorspace_op=matrix, resample_filter_uv="spline36", dither_type="error_diffusion"), _image[i])
        }
    }
    
    Return MessageClip("Done.")
}

Function fw (val c, string frames_file, val frame_types)
{  
    global _c = c
    global _frame_types = frame_types
    for (i = 0, FrameCount(c[0]) - 1)
    {
        current_frame = i
        
        ScriptClip(c[0], """
            if (
            \ (_frame_types[0] == 1) ?
                \ String(propGetString("_PictType")) == "I" :
            \ (_frame_types[0] == 2) ?
                \ String(propGetString("_PictType")) == "P" :
            \ (_frame_types[0] == 3) ?
                \ String(propGetString("_PictType")) == "B" :
            \ (String(propGetString("_PictType")) == "P" || String(propGetString("_PictType")) == "B"))
            {
                check = 1
                                
                for (j = 1, ArraySize(_c) - 1)
                {
                    _c[j]

                    if (
                    \ (_frame_types[j] == 1) ?
                        \ String(propGetString("_PictType")) == "I" :
                    \ (_frame_types[j] == 2) ?
                        \ String(propGetString("_PictType")) == "P" :
                    \ (_frame_types[j] == 3) ?
                        \ String(propGetString("_PictType")) == "B" :
                    \ (String(propGetString("_PictType")) == "P" || String(propGetString("_PictType")) == "B"))
                    {
                        check = check + j
                    }
                }
                
                if ((check == 2 && ArraySize(_c) == 2) || (check == 4 && ArraySize(_c) == 3) || (check == 7 && ArraySize(_c) == 4) || (check == 11 && ArraySize(_c) == 5)) 
                {
                    WriteFile(last, frames_file, "i")
                }
            } """, after_frame=true)
                
        AverageLuma()
    }
}

function simage (clip s, string image_file)
{
    s
    
    for (i = 0, FrameCount() - 1)
    {
        current_frame = i
        ImageWriter(image_file, start=i, end=i, type="png")
        ConvertToY8().AverageLuma()
    }
}
